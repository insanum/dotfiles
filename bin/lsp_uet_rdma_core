#!/bin/bash

set -e  # Exit on error

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Default Configuration
DEFAULT_LINUX_HOST="172.16.71.13"
DEFAULT_LINUX_USER="edavis"
DEFAULT_LINUX_REPO_ROOT="/home/edavis/sync/uec/uet-rdma-core.fork/wt_uet"
DEFAULT_MACOS_REPO_ROOT="/Volumes/work/sync/uec/uet-rdma-core.fork/wt_uet"
DEFAULT_MACOS_UET_REF_PROV_ROOT="/Volumes/work/sync/uec/uet-ref-prov.fork/wt_pds"
MACOS_LINUX_HEADERS="/Volumes/work/git/linux_kernels/linux/include/uapi"

# Runtime configuration (will be set by command line args or defaults)
LINUX_REMOTE=""  # Will be set to user@host
LINUX_REPO_ROOT=""
MACOS_REPO_ROOT=""
MACOS_UET_REF_PROV_ROOT=""

function usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Sets up LSP (Language Server Protocol) for rdma-core development."
    echo "Runs on macOS and performs the following steps:"
    echo "  1. Triggers a build on the remote Linux host via SSH"
    echo "  2. Fetches the build artifacts (cmake.out and generated headers)"
    echo "  3. Generates compile_commands.json for local LSP use"
    echo ""
    echo "Options:"
    echo "  -r, --remote USER@HOST    SSH remote (default: ${DEFAULT_LINUX_USER}@${DEFAULT_LINUX_HOST})"
    echo "  -l, --linux-root PATH     Linux repo root (default: ${DEFAULT_LINUX_REPO_ROOT})"
    echo "  -m, --macos-root PATH     macOS repo root (default: ${DEFAULT_MACOS_REPO_ROOT})"
    echo "  -u, --uet-ref-prov PATH   macOS uet-ref-prov root (default: ${DEFAULT_MACOS_UET_REF_PROV_ROOT})"
    echo "  -h, --help                Show this help message"
    echo ""
    echo "Requirements:"
    echo "  - Must be run from macOS"
    echo "  - SSH access to Linux build host"
    echo ""
    echo "Examples:"
    echo "  $0"
    echo "  $0 --remote edavis@192.168.1.100"
    echo "  $0 --linux-root /home/user/rdma-core --macos-root /Volumes/work/rdma-core"
    exit 1
}

function log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

function log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

function log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

function parse_args() {
    # Set defaults
    LINUX_REMOTE="${DEFAULT_LINUX_USER}@${DEFAULT_LINUX_HOST}"
    LINUX_REPO_ROOT="${DEFAULT_LINUX_REPO_ROOT}"
    MACOS_REPO_ROOT="${DEFAULT_MACOS_REPO_ROOT}"
    MACOS_UET_REF_PROV_ROOT="${DEFAULT_MACOS_UET_REF_PROV_ROOT}"

    while [[ $# -gt 0 ]]; do
        case $1 in
            -r|--remote)
                LINUX_REMOTE="$2"
                shift 2
                ;;
            -l|--linux-root)
                LINUX_REPO_ROOT="$2"
                shift 2
                ;;
            -m|--macos-root)
                MACOS_REPO_ROOT="$2"
                shift 2
                ;;
            -u|--uet-ref-prov)
                MACOS_UET_REF_PROV_ROOT="$2"
                shift 2
                ;;
            -h|--help)
                usage
                ;;
            *)
                log_error "Unknown option: $1"
                usage
                ;;
        esac
    done

    # Validate LINUX_REMOTE format
    if [[ ! "$LINUX_REMOTE" =~ ^[^@]+@[^@]+$ ]]; then
        log_error "Invalid remote format: $LINUX_REMOTE (expected user@host)"
        exit 1
    fi

    # Extract user and host from LINUX_REMOTE
    LINUX_USER="${LINUX_REMOTE%@*}"
    LINUX_HOST="${LINUX_REMOTE#*@}"
}

function main() {
    log_info "Setting up LSP for rdma-core..."

    # Verify we're on macOS
    if [[ "$(uname)" != "Darwin" ]]; then
        log_error "This script should only be run on macOS!"
        exit 1
    fi

    # Verify Linux headers exist
    if [[ ! -d "${MACOS_LINUX_HEADERS}" ]]; then
        log_warn "Linux headers not found at: ${MACOS_LINUX_HEADERS}"
        log_warn "LSP may not work correctly without them."
    fi

    log_info "Configuration:"
    log_info "  Remote:           ${LINUX_REMOTE}"
    log_info "  Linux root:       ${LINUX_REPO_ROOT}"
    log_info "  macOS root:       ${MACOS_REPO_ROOT}"
    log_info "  UET ref-prov:     ${MACOS_UET_REF_PROV_ROOT}"

    # Step 1: Execute the build process on the Linux host via SSH
    log_info "Step 1/3: Building on Linux host..."
    ssh "${LINUX_REMOTE}" bash -s <<EOF
set -e

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

function log_info() {
    echo -e "\${GREEN}[INFO]\${NC} \$1"
}

function log_error() {
    echo -e "\${RED}[ERROR]\${NC} \$1"
}

# Create compile_commands directory in home directory
# Not local ./compile_commands to prevent mutagen overwrites!
log_info "Creating compile_commands directory in home directory..."
HOME_CC_DIR="\${HOME}/compile_commands"
rm -rf "\${HOME_CC_DIR}"
mkdir -p "\${HOME_CC_DIR}"

# Clean build directory
log_info "Cleaning build directory..."
cd "${LINUX_REPO_ROOT}"
rm -rf build

# Run build and capture output
log_info "Running build (this may take a while)..."
VERBOSE=1 UET_REF_PROV_PATH=/home/${LINUX_USER}/sync/uec/uet-ref-prov.fork/wt_pds ./build.sh | tee "\${HOME_CC_DIR}/cmake.out"

# Copy generated headers
log_info "Copying generated headers..."
cp -r build/include "\${HOME_CC_DIR}/"

log_info "Done! Files are in \${HOME_CC_DIR}/"
EOF

    if [[ $? -ne 0 ]]; then
        log_error "Build failed on Linux host"
        exit 1
    fi

    log_info "Build completed successfully on Linux host"

    # Step 2: Fetch compile_commands directory from Linux system
    log_info "Step 2/3: Fetching build artifacts from ${LINUX_REMOTE}..."
    cd "${MACOS_REPO_ROOT}"
    rm -rf compile_commands
    scp -r "${LINUX_REMOTE}:~/compile_commands" .

    if [[ ! -f compile_commands/cmake.out ]]; then
        log_error "Failed to fetch cmake.out from Linux system"
        exit 1
    fi

    # Step 3: Generate compile_commands.json using compiledb
    log_info "Step 3/3: Generating compile_commands.json..."
    cd compile_commands
    compiledb -S -f -p cmake.out -o compile_commands.json
    cd "${MACOS_REPO_ROOT}"

    if [[ ! -f compile_commands/compile_commands.json ]]; then
        log_error "Failed to generate compile_commands.json"
        exit 1
    fi

    # Add include paths and fix path substitutions in compile_commands.json
    log_info "Fixing paths and adding include directories..."
    python3 - <<EOF
import json
import sys
import re

LINUX_REPO_ROOT = "${LINUX_REPO_ROOT}"
MACOS_REPO_ROOT = "${MACOS_REPO_ROOT}"
MACOS_LINUX_HEADERS = "${MACOS_LINUX_HEADERS}"
MACOS_UET_REF_PROV_ROOT = "${MACOS_UET_REF_PROV_ROOT}"

# Read the compile commands
with open('compile_commands/compile_commands.json', 'r') as f:
    commands = json.load(f)

# Add include paths to each command and fix path substitutions
for cmd in commands:
    # Prefer 'arguments' over 'command' if both exist
    if 'arguments' in cmd:
        # Fix path substitutions in arguments
        new_arguments = []
        for arg in cmd['arguments']:
            if isinstance(arg, str):
                # Replace build/include references with compile_commands/include (relative path)
                arg = arg.replace(
                    f'{LINUX_REPO_ROOT}/build/include',
                    './compile_commands/include'
                )
                arg = arg.replace(LINUX_REPO_ROOT, MACOS_REPO_ROOT)
            new_arguments.append(arg)

        # For commands specified as argument arrays
        new_args = [new_arguments[0]]  # compiler
        new_args.extend([
            f'-I{MACOS_LINUX_HEADERS}',
            '-I./compile_commands/include',
            f'-I{MACOS_UET_REF_PROV_ROOT}',
            f'-I{MACOS_UET_REF_PROV_ROOT}/libfabric_headers/include'
        ])
        new_args.extend(new_arguments[1:])
        cmd['arguments'] = new_args

        # Also fix command string if it exists (for compatibility)
        if 'command' in cmd:
            cmd['command'] = cmd['command'].replace(
                f'{LINUX_REPO_ROOT}/build/include',
                './compile_commands/include'
            )
            cmd['command'] = cmd['command'].replace(LINUX_REPO_ROOT, MACOS_REPO_ROOT)

    elif 'command' in cmd:
        # Fix path substitutions in the command
        cmd['command'] = cmd['command'].replace(
            f'{LINUX_REPO_ROOT}/build/include',
            './compile_commands/include'
        )
        cmd['command'] = cmd['command'].replace(LINUX_REPO_ROOT, MACOS_REPO_ROOT)

        # Find the position after the compiler command (gcc/g++/clang)
        parts = cmd['command'].split()

        # Insert include flags after the compiler command
        new_parts = [parts[0]]  # compiler
        new_parts.extend([
            f'-I{MACOS_LINUX_HEADERS}',
            '-I./compile_commands/include',
            f'-I{MACOS_UET_REF_PROV_ROOT}',
            f'-I{MACOS_UET_REF_PROV_ROOT}/libfabric_headers/include'
        ])
        new_parts.extend(parts[1:])  # rest of the command

        cmd['command'] = ' '.join(new_parts)

    # Fix directory and file paths
    if 'directory' in cmd and isinstance(cmd['directory'], str):
        cmd['directory'] = cmd['directory'].replace(LINUX_REPO_ROOT, MACOS_REPO_ROOT)

    if 'file' in cmd and isinstance(cmd['file'], str):
        cmd['file'] = cmd['file'].replace(LINUX_REPO_ROOT, MACOS_REPO_ROOT)

# Write back the modified commands
with open('compile_commands/compile_commands.json', 'w') as f:
    json.dump(commands, f, indent=2)

print("Successfully added include paths and fixed path substitutions")
EOF

    if [[ $? -ne 0 ]]; then
        log_error "Failed to modify compile_commands.json"
        exit 1
    fi

    # Copy to current directory for LSP
    log_info "Copying compile_commands.json to project root..."
    cp compile_commands/compile_commands.json compile_commands.json

    log_info "Done! Your LSP should now be configured."
    log_info "compile_commands.json is ready at: ${MACOS_REPO_ROOT}/compile_commands.json"
    log_info "Note: compile_commands/ directory preserved for LSP includes"
}

# Main entry point
parse_args "$@"
main

